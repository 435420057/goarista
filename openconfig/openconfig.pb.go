// Copyright 2015 Google, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go.
// source: openconfig.proto
// DO NOT EDIT!

/*
Package openconfig is a generated protocol buffer package.

Package openconfig defines the gRPC service for getting and setting the
OpenConfig configuration and state of a network device.

This package and its contents have not been ratified by OpenConfig.  It is
a working proposal by Google.

It is generated from these files:
	openconfig.proto

It has these top-level messages:
	Path
	Value
	Update
	Notification
	UDPWrapper
	Error
	SubscribeRequest
	SubscribeResponse
	SubscriptionList
	Subscription
	AliasList
	Alias
	Heartbeat
	SyncRequest
	GetRequest
	GetResponse
	SetRequest
	SetResponse
	UpdateResponse
*/
package openconfig

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/any"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.ProtoPackageIsVersion1

// A Type describes what format a Value's data is encoded in.
type Type int32

const (
	Type_JSON  Type = 0
	Type_BYTES Type = 1
)

var Type_name = map[int32]string{
	0: "JSON",
	1: "BYTES",
}
var Type_value = map[string]int32{
	"JSON":  0,
	"BYTES": 1,
}

func (x Type) String() string {
	return proto.EnumName(Type_name, int32(x))
}
func (Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// A Path represents an open config path as a list of strings, one element
// per string.
type Path struct {
	Element []string `protobuf:"bytes,1,rep,name=element" json:"element,omitempty"`
}

func (m *Path) Reset()                    { *m = Path{} }
func (m *Path) String() string            { return proto.CompactTextString(m) }
func (*Path) ProtoMessage()               {}
func (*Path) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// A Value is either raw data or a JSON encoded value.  An enumerated value is
// of type JSON, with the numeric value in the value field and the name of the
// enumerated value in the name field.
type Value struct {
	Value []byte `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	Type  Type   `protobuf:"varint,2,opt,name=type,enum=openconfig.Type" json:"type,omitempty"`
	Name  string `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
}

func (m *Value) Reset()                    { *m = Value{} }
func (m *Value) String() string            { return proto.CompactTextString(m) }
func (*Value) ProtoMessage()               {}
func (*Value) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// An Update maps a path to a value.
//
// In a Notification, an Update represents a new or updated value for path.  The
// absolute path name is the concatenation of the Notification prefix and the
// Update path.  Updates are only sent by the target.  Path must always specify
// a leaf node.  Value should be a scalar value (e.g., if Value is JSON encoded
// then the value 123 is acceptable, but {"x":123} is not).
//
// In a SetRequest, an Update contains a path to a read-write node and an
// optional value.  The absolute path name is the concatenation of the
// SetRequest prefix and the Update path The path may reference either a
// directory or leaf node.  If value is not present then path, and all its
// subelements, should be removed.  If value set and path references a directory
// node, the value is the JSON encoded tree of values below that node,
// otherwise, if the value is a scalar and may be encoded in JSON are as raw
// BYTES.  the value
//
// For an example of updating a directory node, consider a tree that has the
// following values:
//
//   /a/b/c: 1
//   /a/b/d: 2
//   /a/b/e: 3
//
// And an Update of
//
//   Path: /a/b
//   Value: "{c: 4, f: 5}"
//
// The result is that /a/b/d and /a/b/e are removed, /a/b/c now has the value of
// 4, and /a/b/f is added with the value of 5.
type Update struct {
	Path  *Path  `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	Value *Value `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *Update) Reset()                    { *m = Update{} }
func (m *Update) String() string            { return proto.CompactTextString(m) }
func (*Update) ProtoMessage()               {}
func (*Update) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Update) GetPath() *Path {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *Update) GetValue() *Value {
	if m != nil {
		return m.Value
	}
	return nil
}

// A Notification is a list of updates to apply.  Deletes are a list of paths to
// delete as long as their data is older than timestamp.  Deleting nodes deletes
// all values below the node that are older than timestamp.  Deletes are
// performed after updates are applied.  Delete paths are created by
// concatenating the prefix, if present, with the individual paths.
//
// Update paths are created by concatenating the prefix, if present, with the
// paths contained in the Updates.
//
// It is valid to have a path be both in an update and match a delete.  The
// deletion will only delete values that are older than this update.
//
// Each notification should contain at most a single update for a given path.
// If a nonconforming implementation does send multiple updates for a given path
// in a single notification, all but the final update should be ignored.
//
// The prefix should normally be the longest common prefix to all the individual
// update and delete path.  This reduces the repetition of the common prefix in
// each update and/or delete.  The individual updates and deletes also are a
// Path (repeated list of elements), allowing a notification such as:
//
//   prefix: /a/b/c
//   update: {
//     path: d
//     value: x
//   }
//   update: {
//     path: e/f
//     value: y
//   }
//   update: {
//     path: e/g
//     value: z
//   }
//
// The prefix may begin with an alias.  An alias is a Path with 1 or more
// elements, which maps to another Path.  Aliases may be defined by either the
// target or the client.  Target defined aliases are limited to a single
// element.  Aliases are client specific (though a target may define the same
// alias for multiple clients).
//
// The target defines an alias by sending a Notification that has alias set and
// a non-empty prefix. When alias is set, a Notification need not provide
// updates or deletes.  If the alias was previously defined, it is over ridden
// with the new definition.  Once defined, the target may send the value of
// alias as the first element of a prefix.  A target must not send target
// defined aliases to clients that do not specify the use_aliases option in the
// initial SubscriptionList message.  A target does not need to define aliases
// even if the client does specify the use_aliases option in the initial
// SubscriptionLlist message.
//
// Clients define aliases by sending a SubscriptionRequest with aliases set.
//
// A target should use a define alias when possible, but is not required to.  A
// target may ignore client defined aliases.
//
// Clients should not define aliases that valid paths in the data tree.  The
// target must not define aliases that valid paths in the dat tree.
//
// If a target sends a notification with alias set, but not prefix, then it is
// indicating it will no longer use this alias.  The client may delete this
// alias from its list of aliases.  A target may not delete an alias defined by
// the client.  It is implementation dependent on what happens if the client
// defines an alias that is also defined by the target.
//
// Aliases must not be used in UDP packets.
//
// If a client sets the use_aliases option, or defines aliases, in the initial
// SubscriptionList message, then it must always check the initial elements of a
// prefix against the list of known aliases, expanding the prefix as needed.
// Aliases must always be defined as fully expanded prefixes.  Only single alias
// lookup is needed per Notification.
//
// Target defined aliases may be any unique string.  A target may choose to use
// a unique prefix for aliases to make them visually distinct.  For example, a
// target might construct all aliases as an @ character followed by a decimal or
// hexadecimal number (perhaps a hashed address in memory).
//
// Example:
//
// Define @42 as an alias:
//
//   timestamp: 1439416376123456789
//   prefix: "this_is"
//   prefix: "a_long"
//   prefix: "prefix"
//   alias: "@42
//
// Use @42 as an alias to set /this_is/a_long/prefix/Ethernet0/0/1/in-octets to
// 17:
//
//   timestamp: 1439416376456456456
//   prefix: "@42"
//   prefix: "Ethernet0/0/1"
//   update: {
//     path: {
//       element: "in-octets"
//     }
//     value: 17
//   }
//
// Delete the alias @42:
//
//   timestamp: 1439416376987654321
//   alias: @42
type Notification struct {
	Timestamp int64     `protobuf:"varint,1,opt,name=timestamp" json:"timestamp,omitempty"`
	Prefix    *Path     `protobuf:"bytes,2,opt,name=prefix" json:"prefix,omitempty"`
	Alias     string    `protobuf:"bytes,3,opt,name=alias" json:"alias,omitempty"`
	Update    []*Update `protobuf:"bytes,4,rep,name=update" json:"update,omitempty"`
	Delete    []*Path   `protobuf:"bytes,5,rep,name=delete" json:"delete,omitempty"`
}

func (m *Notification) Reset()                    { *m = Notification{} }
func (m *Notification) String() string            { return proto.CompactTextString(m) }
func (*Notification) ProtoMessage()               {}
func (*Notification) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Notification) GetPrefix() *Path {
	if m != nil {
		return m.Prefix
	}
	return nil
}

func (m *Notification) GetUpdate() []*Update {
	if m != nil {
		return m.Update
	}
	return nil
}

func (m *Notification) GetDelete() []*Path {
	if m != nil {
		return m.Delete
	}
	return nil
}

// UDPWrapper adds metadata necessary for encapsulating a list of notifications
// into a UDP packet.  It adds the ability to identify the agent that originated
// the Notifications, detect packet loss, and identify latency introduced by
// the target wrapping notifications.
//
// The target should keep the total size of a serialized UDPWrapper message
// small enough to not cause IP packet fragmentation.
type UDPWrapper struct {
	// ID Identifies the device (e.g., Loopback IP address, linecard, ...)
	// TODO(borman): Add examples.  Perhaps Agent/module/submodule for juniper.
	Id *Path `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// Optional Epoch time of when the message is queued for transmit.
	// Useful to quantify delay between message generation and transmission.
	TransmitTimestamp uint64 `protobuf:"varint,2,opt,name=transmit_timestamp,json=transmitTimestamp" json:"transmit_timestamp,omitempty"`
	// The sequence_number must start at 1 and increment by 1 for each new packet
	// sent.  A client may use this to determine if a packet was lost.
	SequenceNumber uint64          `protobuf:"varint,3,opt,name=sequence_number,json=sequenceNumber" json:"sequence_number,omitempty"`
	Notification   []*Notification `protobuf:"bytes,4,rep,name=notification" json:"notification,omitempty"`
}

func (m *UDPWrapper) Reset()                    { *m = UDPWrapper{} }
func (m *UDPWrapper) String() string            { return proto.CompactTextString(m) }
func (*UDPWrapper) ProtoMessage()               {}
func (*UDPWrapper) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *UDPWrapper) GetId() *Path {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *UDPWrapper) GetNotification() []*Notification {
	if m != nil {
		return m.Notification
	}
	return nil
}

// An Error contains information about why a particular request failed.
//
// The canonical error codes are defined for each language.
//
//   Go:   import "google.golang.org/grpc/codes"
//   C++:  #include <grpc++/status_code_enum.h>
//   Java: import static io.grpc.Status.Code;
//   C:    #include <grpc/status.h>
//   C#:   using Grpc.Core;
type Error struct {
	Code    uint32               `protobuf:"varint,1,opt,name=code" json:"code,omitempty"`
	Message string               `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
	Data    *google_protobuf.Any `protobuf:"bytes,3,opt,name=data" json:"data,omitempty"`
}

func (m *Error) Reset()                    { *m = Error{} }
func (m *Error) String() string            { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()               {}
func (*Error) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Error) GetData() *google_protobuf.Any {
	if m != nil {
		return m.Data
	}
	return nil
}

// A SubscribeRequest is either a subscription request, a change to the
// heartbeat rate, or a request for resynchronization of data.  It is always
// sent from the client to the target.
//
// Proxy is a list of proxies to use to get to the target.  The first proxy
// listed is the address of the next hop.  Targets ignore the proxy field (it
// should not be set).
type SubscribeRequest struct {
	// Types that are valid to be assigned to Request:
	//	*SubscribeRequest_Subscribe
	//	*SubscribeRequest_Heartbeat
	//	*SubscribeRequest_Sync
	//	*SubscribeRequest_Aliases
	Request isSubscribeRequest_Request `protobuf_oneof:"request"`
	Proxy   []string                   `protobuf:"bytes,5,rep,name=proxy" json:"proxy,omitempty"`
}

func (m *SubscribeRequest) Reset()                    { *m = SubscribeRequest{} }
func (m *SubscribeRequest) String() string            { return proto.CompactTextString(m) }
func (*SubscribeRequest) ProtoMessage()               {}
func (*SubscribeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

type isSubscribeRequest_Request interface {
	isSubscribeRequest_Request()
}

type SubscribeRequest_Subscribe struct {
	Subscribe *SubscriptionList `protobuf:"bytes,1,opt,name=subscribe,oneof"`
}
type SubscribeRequest_Heartbeat struct {
	Heartbeat *Heartbeat `protobuf:"bytes,2,opt,name=heartbeat,oneof"`
}
type SubscribeRequest_Sync struct {
	Sync *SyncRequest `protobuf:"bytes,3,opt,name=sync,oneof"`
}
type SubscribeRequest_Aliases struct {
	Aliases *AliasList `protobuf:"bytes,4,opt,name=aliases,oneof"`
}

func (*SubscribeRequest_Subscribe) isSubscribeRequest_Request() {}
func (*SubscribeRequest_Heartbeat) isSubscribeRequest_Request() {}
func (*SubscribeRequest_Sync) isSubscribeRequest_Request()      {}
func (*SubscribeRequest_Aliases) isSubscribeRequest_Request()   {}

func (m *SubscribeRequest) GetRequest() isSubscribeRequest_Request {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *SubscribeRequest) GetSubscribe() *SubscriptionList {
	if x, ok := m.GetRequest().(*SubscribeRequest_Subscribe); ok {
		return x.Subscribe
	}
	return nil
}

func (m *SubscribeRequest) GetHeartbeat() *Heartbeat {
	if x, ok := m.GetRequest().(*SubscribeRequest_Heartbeat); ok {
		return x.Heartbeat
	}
	return nil
}

func (m *SubscribeRequest) GetSync() *SyncRequest {
	if x, ok := m.GetRequest().(*SubscribeRequest_Sync); ok {
		return x.Sync
	}
	return nil
}

func (m *SubscribeRequest) GetAliases() *AliasList {
	if x, ok := m.GetRequest().(*SubscribeRequest_Aliases); ok {
		return x.Aliases
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SubscribeRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SubscribeRequest_OneofMarshaler, _SubscribeRequest_OneofUnmarshaler, _SubscribeRequest_OneofSizer, []interface{}{
		(*SubscribeRequest_Subscribe)(nil),
		(*SubscribeRequest_Heartbeat)(nil),
		(*SubscribeRequest_Sync)(nil),
		(*SubscribeRequest_Aliases)(nil),
	}
}

func _SubscribeRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SubscribeRequest)
	// request
	switch x := m.Request.(type) {
	case *SubscribeRequest_Subscribe:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Subscribe); err != nil {
			return err
		}
	case *SubscribeRequest_Heartbeat:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Heartbeat); err != nil {
			return err
		}
	case *SubscribeRequest_Sync:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Sync); err != nil {
			return err
		}
	case *SubscribeRequest_Aliases:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Aliases); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("SubscribeRequest.Request has unexpected type %T", x)
	}
	return nil
}

func _SubscribeRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SubscribeRequest)
	switch tag {
	case 1: // request.subscribe
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SubscriptionList)
		err := b.DecodeMessage(msg)
		m.Request = &SubscribeRequest_Subscribe{msg}
		return true, err
	case 2: // request.heartbeat
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Heartbeat)
		err := b.DecodeMessage(msg)
		m.Request = &SubscribeRequest_Heartbeat{msg}
		return true, err
	case 3: // request.sync
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SyncRequest)
		err := b.DecodeMessage(msg)
		m.Request = &SubscribeRequest_Sync{msg}
		return true, err
	case 4: // request.aliases
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AliasList)
		err := b.DecodeMessage(msg)
		m.Request = &SubscribeRequest_Aliases{msg}
		return true, err
	default:
		return false, nil
	}
}

func _SubscribeRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SubscribeRequest)
	// request
	switch x := m.Request.(type) {
	case *SubscribeRequest_Subscribe:
		s := proto.Size(x.Subscribe)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SubscribeRequest_Heartbeat:
		s := proto.Size(x.Heartbeat)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SubscribeRequest_Sync:
		s := proto.Size(x.Sync)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SubscribeRequest_Aliases:
		s := proto.Size(x.Aliases)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// A SubscribeResponse is always sent from the target to the client.
type SubscribeResponse struct {
	// Types that are valid to be assigned to Response:
	//	*SubscribeResponse_Update
	//	*SubscribeResponse_Heartbeat
	//	*SubscribeResponse_SyncResponse
	Response isSubscribeResponse_Response `protobuf_oneof:"response"`
}

func (m *SubscribeResponse) Reset()                    { *m = SubscribeResponse{} }
func (m *SubscribeResponse) String() string            { return proto.CompactTextString(m) }
func (*SubscribeResponse) ProtoMessage()               {}
func (*SubscribeResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

type isSubscribeResponse_Response interface {
	isSubscribeResponse_Response()
}

type SubscribeResponse_Update struct {
	Update *Notification `protobuf:"bytes,1,opt,name=update,oneof"`
}
type SubscribeResponse_Heartbeat struct {
	Heartbeat *Heartbeat `protobuf:"bytes,2,opt,name=heartbeat,oneof"`
}
type SubscribeResponse_SyncResponse struct {
	SyncResponse uint64 `protobuf:"varint,3,opt,name=sync_response,json=syncResponse,oneof"`
}

func (*SubscribeResponse_Update) isSubscribeResponse_Response()       {}
func (*SubscribeResponse_Heartbeat) isSubscribeResponse_Response()    {}
func (*SubscribeResponse_SyncResponse) isSubscribeResponse_Response() {}

func (m *SubscribeResponse) GetResponse() isSubscribeResponse_Response {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *SubscribeResponse) GetUpdate() *Notification {
	if x, ok := m.GetResponse().(*SubscribeResponse_Update); ok {
		return x.Update
	}
	return nil
}

func (m *SubscribeResponse) GetHeartbeat() *Heartbeat {
	if x, ok := m.GetResponse().(*SubscribeResponse_Heartbeat); ok {
		return x.Heartbeat
	}
	return nil
}

func (m *SubscribeResponse) GetSyncResponse() uint64 {
	if x, ok := m.GetResponse().(*SubscribeResponse_SyncResponse); ok {
		return x.SyncResponse
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SubscribeResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SubscribeResponse_OneofMarshaler, _SubscribeResponse_OneofUnmarshaler, _SubscribeResponse_OneofSizer, []interface{}{
		(*SubscribeResponse_Update)(nil),
		(*SubscribeResponse_Heartbeat)(nil),
		(*SubscribeResponse_SyncResponse)(nil),
	}
}

func _SubscribeResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SubscribeResponse)
	// response
	switch x := m.Response.(type) {
	case *SubscribeResponse_Update:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Update); err != nil {
			return err
		}
	case *SubscribeResponse_Heartbeat:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Heartbeat); err != nil {
			return err
		}
	case *SubscribeResponse_SyncResponse:
		b.EncodeVarint(3<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.SyncResponse))
	case nil:
	default:
		return fmt.Errorf("SubscribeResponse.Response has unexpected type %T", x)
	}
	return nil
}

func _SubscribeResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SubscribeResponse)
	switch tag {
	case 1: // response.update
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Notification)
		err := b.DecodeMessage(msg)
		m.Response = &SubscribeResponse_Update{msg}
		return true, err
	case 2: // response.heartbeat
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Heartbeat)
		err := b.DecodeMessage(msg)
		m.Response = &SubscribeResponse_Heartbeat{msg}
		return true, err
	case 3: // response.sync_response
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Response = &SubscribeResponse_SyncResponse{x}
		return true, err
	default:
		return false, nil
	}
}

func _SubscribeResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SubscribeResponse)
	// response
	switch x := m.Response.(type) {
	case *SubscribeResponse_Update:
		s := proto.Size(x.Update)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SubscribeResponse_Heartbeat:
		s := proto.Size(x.Heartbeat)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *SubscribeResponse_SyncResponse:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.SyncResponse))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// SubscriptionList contains the list of individual subscriptions.  A
// SubscriptionList is only valid if all of the contained subscriptions are
// valid.  Setting once to false or poll_interval to 0 is the equivalent of the
// mode not being set (i.e., streaming).
//
// If prefix is set then all subscriptions in the list and all notifications
// generated are relative to prefix.
//
// If poll_interval is not set, then a SubscriptionList must only be sent once.
// If poll_interval is set, the SubscriptionLists following the initial
// SubscriptionList must only contain a poll_interval.
type SubscriptionList struct {
	// Types that are valid to be assigned to Mode:
	//	*SubscriptionList_Once
	//	*SubscriptionList_PollInterval
	Mode         isSubscriptionList_Mode   `protobuf_oneof:"mode"`
	Subscription []*Subscription           `protobuf:"bytes,1,rep,name=subscription" json:"subscription,omitempty"`
	Prefix       *Path                     `protobuf:"bytes,2,opt,name=prefix" json:"prefix,omitempty"`
	Options      *SubscriptionList_Options `protobuf:"bytes,3,opt,name=options" json:"options,omitempty"`
}

func (m *SubscriptionList) Reset()                    { *m = SubscriptionList{} }
func (m *SubscriptionList) String() string            { return proto.CompactTextString(m) }
func (*SubscriptionList) ProtoMessage()               {}
func (*SubscriptionList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

type isSubscriptionList_Mode interface {
	isSubscriptionList_Mode()
}

type SubscriptionList_Once struct {
	Once bool `protobuf:"varint,10,opt,name=once,oneof"`
}
type SubscriptionList_PollInterval struct {
	PollInterval uint64 `protobuf:"varint,11,opt,name=poll_interval,json=pollInterval,oneof"`
}

func (*SubscriptionList_Once) isSubscriptionList_Mode()         {}
func (*SubscriptionList_PollInterval) isSubscriptionList_Mode() {}

func (m *SubscriptionList) GetMode() isSubscriptionList_Mode {
	if m != nil {
		return m.Mode
	}
	return nil
}

func (m *SubscriptionList) GetOnce() bool {
	if x, ok := m.GetMode().(*SubscriptionList_Once); ok {
		return x.Once
	}
	return false
}

func (m *SubscriptionList) GetPollInterval() uint64 {
	if x, ok := m.GetMode().(*SubscriptionList_PollInterval); ok {
		return x.PollInterval
	}
	return 0
}

func (m *SubscriptionList) GetSubscription() []*Subscription {
	if m != nil {
		return m.Subscription
	}
	return nil
}

func (m *SubscriptionList) GetPrefix() *Path {
	if m != nil {
		return m.Prefix
	}
	return nil
}

func (m *SubscriptionList) GetOptions() *SubscriptionList_Options {
	if m != nil {
		return m.Options
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SubscriptionList) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SubscriptionList_OneofMarshaler, _SubscriptionList_OneofUnmarshaler, _SubscriptionList_OneofSizer, []interface{}{
		(*SubscriptionList_Once)(nil),
		(*SubscriptionList_PollInterval)(nil),
	}
}

func _SubscriptionList_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SubscriptionList)
	// mode
	switch x := m.Mode.(type) {
	case *SubscriptionList_Once:
		t := uint64(0)
		if x.Once {
			t = 1
		}
		b.EncodeVarint(10<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *SubscriptionList_PollInterval:
		b.EncodeVarint(11<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.PollInterval))
	case nil:
	default:
		return fmt.Errorf("SubscriptionList.Mode has unexpected type %T", x)
	}
	return nil
}

func _SubscriptionList_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SubscriptionList)
	switch tag {
	case 10: // mode.once
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Mode = &SubscriptionList_Once{x != 0}
		return true, err
	case 11: // mode.poll_interval
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Mode = &SubscriptionList_PollInterval{x}
		return true, err
	default:
		return false, nil
	}
}

func _SubscriptionList_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SubscriptionList)
	// mode
	switch x := m.Mode.(type) {
	case *SubscriptionList_Once:
		n += proto.SizeVarint(10<<3 | proto.WireVarint)
		n += 1
	case *SubscriptionList_PollInterval:
		n += proto.SizeVarint(11<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.PollInterval))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type SubscriptionList_Options struct {
	UseAliases bool `protobuf:"varint,1,opt,name=use_aliases,json=useAliases" json:"use_aliases,omitempty"`
}

func (m *SubscriptionList_Options) Reset()                    { *m = SubscriptionList_Options{} }
func (m *SubscriptionList_Options) String() string            { return proto.CompactTextString(m) }
func (*SubscriptionList_Options) ProtoMessage()               {}
func (*SubscriptionList_Options) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8, 0} }

// Subscription contains a path as well as the target side coalesce_interval for
// aggregating values, typically counters.  If the target cannot support the
// interval the subscription must be rejected.  The coalesce_interval is only
// used for subscriptions in streaming mode.  If the coalesce_interval is 0 then
// the coalesce_interval is target specified.
type Subscription struct {
	Path             *Path  `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	CoalesceInterval uint64 `protobuf:"varint,2,opt,name=coalesce_interval,json=coalesceInterval" json:"coalesce_interval,omitempty"`
}

func (m *Subscription) Reset()                    { *m = Subscription{} }
func (m *Subscription) String() string            { return proto.CompactTextString(m) }
func (*Subscription) ProtoMessage()               {}
func (*Subscription) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *Subscription) GetPath() *Path {
	if m != nil {
		return m.Path
	}
	return nil
}

// An AliasList represents a list of aliases.
type AliasList struct {
	Alias []*Alias `protobuf:"bytes,1,rep,name=alias" json:"alias,omitempty"`
}

func (m *AliasList) Reset()                    { *m = AliasList{} }
func (m *AliasList) String() string            { return proto.CompactTextString(m) }
func (*AliasList) ProtoMessage()               {}
func (*AliasList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *AliasList) GetAlias() []*Alias {
	if m != nil {
		return m.Alias
	}
	return nil
}

// An Alias specifies a preferred client defined alias for a specified path.  An
// Alias is only sent from the client to the target.  An alias is typically one
// element and is much shorter than the provided path.  A target should
// substitute alias for path in Notifications.  Targets may ignore Alias
// messages.
//
// The path must be fully expanded and not use an alias.
//
// If alias is set and path is not then the alias must no longer be used by the
// target, once received.  A client may still see Notifications using the alias
// that were generated prior to the target receiving the request to stop using
// the alias.
type Alias struct {
	Path  *Path `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	Alias *Path `protobuf:"bytes,2,opt,name=alias" json:"alias,omitempty"`
}

func (m *Alias) Reset()                    { *m = Alias{} }
func (m *Alias) String() string            { return proto.CompactTextString(m) }
func (*Alias) ProtoMessage()               {}
func (*Alias) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *Alias) GetPath() *Path {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *Alias) GetAlias() *Path {
	if m != nil {
		return m.Alias
	}
	return nil
}

// A Heartbeat requests a (possibly repeated) response from the remote side.
type Heartbeat struct {
	// interval is the maximum amount of time, in nanoseconds, between subsequent
	// messages from the remote side.  An empty message may be sent if no other
	// messages are pending.  If interval is 0 then the remote must immediately
	// respond with a (possibly empty) message.
	Interval uint64 `protobuf:"varint,1,opt,name=interval" json:"interval,omitempty"`
}

func (m *Heartbeat) Reset()                    { *m = Heartbeat{} }
func (m *Heartbeat) String() string            { return proto.CompactTextString(m) }
func (*Heartbeat) ProtoMessage()               {}
func (*Heartbeat) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

// A SyncRequest requests that all values identified by path be resent.  The
// target should respond with a series of updates and then a sync_response with
// the provided id, which should not be zero.
//
// A target is suggested to keep a timestamp of when the SyncRequest starts,
// followed by notifications, all of which are past the starting timestamp.
// Before sending the sync_response, a delete for each of the paths should be
// made with the starting timestamp.  This will assure the client removes all
// stale data that was not part of the update.
//
// If prefix is set, each path is relative to prefix.
type SyncRequest struct {
	Id     uint64  `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	Prefix *Path   `protobuf:"bytes,2,opt,name=prefix" json:"prefix,omitempty"`
	Path   []*Path `protobuf:"bytes,3,rep,name=path" json:"path,omitempty"`
}

func (m *SyncRequest) Reset()                    { *m = SyncRequest{} }
func (m *SyncRequest) String() string            { return proto.CompactTextString(m) }
func (*SyncRequest) ProtoMessage()               {}
func (*SyncRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *SyncRequest) GetPrefix() *Path {
	if m != nil {
		return m.Prefix
	}
	return nil
}

func (m *SyncRequest) GetPath() []*Path {
	if m != nil {
		return m.Path
	}
	return nil
}

type GetRequest struct {
	Prefix *Path   `protobuf:"bytes,1,opt,name=prefix" json:"prefix,omitempty"`
	Path   []*Path `protobuf:"bytes,2,rep,name=path" json:"path,omitempty"`
	// If cache_interval is provided and is non-zero number of nanoseconds, it is
	// a hint of when this get request will be repeated in the future.
	CacheInterval int64 `protobuf:"varint,3,opt,name=cache_interval,json=cacheInterval" json:"cache_interval,omitempty"`
}

func (m *GetRequest) Reset()                    { *m = GetRequest{} }
func (m *GetRequest) String() string            { return proto.CompactTextString(m) }
func (*GetRequest) ProtoMessage()               {}
func (*GetRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *GetRequest) GetPrefix() *Path {
	if m != nil {
		return m.Prefix
	}
	return nil
}

func (m *GetRequest) GetPath() []*Path {
	if m != nil {
		return m.Path
	}
	return nil
}

type GetResponse struct {
	Notification []*Notification `protobuf:"bytes,1,rep,name=notification" json:"notification,omitempty"`
}

func (m *GetResponse) Reset()                    { *m = GetResponse{} }
func (m *GetResponse) String() string            { return proto.CompactTextString(m) }
func (*GetResponse) ProtoMessage()               {}
func (*GetResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *GetResponse) GetNotification() []*Notification {
	if m != nil {
		return m.Notification
	}
	return nil
}

// A SetRequest contains an optional prefix, a list of zero or more Paths to
// delete and a list of zero or more Updates.  The delete and update paths are
// relative to prefix.  Deletes should appear to happen prior to updates being
// applied.  This supports delete, update, and replace:
//
//   delete - a path is listed in the delete field
//   update - a path is listed in the update field
//   replace - a path is listed in both the delete field and the update field.
//
// The target must either apply all the deletes and updates or return an error.
// The deletes and updates should appear to be atomically applied.
type SetRequest struct {
	Prefix *Path     `protobuf:"bytes,1,opt,name=prefix" json:"prefix,omitempty"`
	Delete []*Path   `protobuf:"bytes,2,rep,name=delete" json:"delete,omitempty"`
	Update []*Update `protobuf:"bytes,3,rep,name=update" json:"update,omitempty"`
}

func (m *SetRequest) Reset()                    { *m = SetRequest{} }
func (m *SetRequest) String() string            { return proto.CompactTextString(m) }
func (*SetRequest) ProtoMessage()               {}
func (*SetRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *SetRequest) GetPrefix() *Path {
	if m != nil {
		return m.Prefix
	}
	return nil
}

func (m *SetRequest) GetDelete() []*Path {
	if m != nil {
		return m.Delete
	}
	return nil
}

func (m *SetRequest) GetUpdate() []*Update {
	if m != nil {
		return m.Update
	}
	return nil
}

// A SetResponse contains responses to a SetRequest.  The optional prefix is
// applied to all paths in response.  Each path provided by a SetRequest needs a
// response, but there need not be a 1:1 correspondence between SetRequests and
// SetResponses (e.g., the target may issue a single response to multiple
// requests, or multiple responses to a single request).
type SetResponse struct {
	Prefix   *Path             `protobuf:"bytes,1,opt,name=prefix" json:"prefix,omitempty"`
	Response []*UpdateResponse `protobuf:"bytes,2,rep,name=response" json:"response,omitempty"`
}

func (m *SetResponse) Reset()                    { *m = SetResponse{} }
func (m *SetResponse) String() string            { return proto.CompactTextString(m) }
func (*SetResponse) ProtoMessage()               {}
func (*SetResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *SetResponse) GetPrefix() *Path {
	if m != nil {
		return m.Prefix
	}
	return nil
}

func (m *SetResponse) GetResponse() []*UpdateResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

// An UpdateResponse contains the response for a single path Update.
type UpdateResponse struct {
	Path  *Path  `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	Error *Error `protobuf:"bytes,2,opt,name=error" json:"error,omitempty"`
	// The timestamp is the time, in nanoseconds since the epoch, that a Set was
	// accepted (i.e., the request was valid).  It does not imply the value was
	// actually propagated to an underlying datastore.
	Timestamp int64 `protobuf:"varint,3,opt,name=timestamp" json:"timestamp,omitempty"`
}

func (m *UpdateResponse) Reset()                    { *m = UpdateResponse{} }
func (m *UpdateResponse) String() string            { return proto.CompactTextString(m) }
func (*UpdateResponse) ProtoMessage()               {}
func (*UpdateResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *UpdateResponse) GetPath() *Path {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *UpdateResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

func init() {
	proto.RegisterType((*Path)(nil), "openconfig.Path")
	proto.RegisterType((*Value)(nil), "openconfig.Value")
	proto.RegisterType((*Update)(nil), "openconfig.Update")
	proto.RegisterType((*Notification)(nil), "openconfig.Notification")
	proto.RegisterType((*UDPWrapper)(nil), "openconfig.UDPWrapper")
	proto.RegisterType((*Error)(nil), "openconfig.Error")
	proto.RegisterType((*SubscribeRequest)(nil), "openconfig.SubscribeRequest")
	proto.RegisterType((*SubscribeResponse)(nil), "openconfig.SubscribeResponse")
	proto.RegisterType((*SubscriptionList)(nil), "openconfig.SubscriptionList")
	proto.RegisterType((*SubscriptionList_Options)(nil), "openconfig.SubscriptionList.Options")
	proto.RegisterType((*Subscription)(nil), "openconfig.Subscription")
	proto.RegisterType((*AliasList)(nil), "openconfig.AliasList")
	proto.RegisterType((*Alias)(nil), "openconfig.Alias")
	proto.RegisterType((*Heartbeat)(nil), "openconfig.Heartbeat")
	proto.RegisterType((*SyncRequest)(nil), "openconfig.SyncRequest")
	proto.RegisterType((*GetRequest)(nil), "openconfig.GetRequest")
	proto.RegisterType((*GetResponse)(nil), "openconfig.GetResponse")
	proto.RegisterType((*SetRequest)(nil), "openconfig.SetRequest")
	proto.RegisterType((*SetResponse)(nil), "openconfig.SetResponse")
	proto.RegisterType((*UpdateResponse)(nil), "openconfig.UpdateResponse")
	proto.RegisterEnum("openconfig.Type", Type_name, Type_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion2

// Client API for OpenConfig service

type OpenConfigClient interface {
	// Subscribe subscribes for streaming updates.  Streaming updates are provided
	// as a series of Notifications, each of which update a portion of the tree.
	// The target must send the current values of all subscribed paths at the
	// start of the stream, followed by a sync_response of 0.
	//
	// A Subscription operates in one of three modes.
	//
	// Streaming:  This is the default mode.  The target sends continual updates
	// of each value as specified by each subscription's coalesce_interval.  The
	// client may request the target to resend the current value of a set of paths
	// by sending a SyncRequest.
	//
	// Once: This mode is specified by setting once to true in the
	// SubscriptionRequest.  The target must close the stream after sending
	// the sync_response of 0.  The target should only send each value once.
	//
	// Poll: This mode is the equivalent of periodic Once requests but sent over a
	// single stream.  Polling is specified by setting poll_interval in the
	// SubscriptionRequest to the expected number of nanoseconds between polls.
	// The target stops sending updates after sending the sync_response of 0.
	// After the polling interval, the client sends a new SubscriptionRequest with
	// only the poll_interval set.  The target must respond by sending the current
	// values of all subscribed paths, once again followed with a sync_response of
	// 0.  This process then repeats until the client closes the request stream.
	Subscribe(ctx context.Context, opts ...grpc.CallOption) (OpenConfig_SubscribeClient, error)
	// Get requests a single snapshot of the requested data.  A Get request may
	// contain a hint that the request will be repeated (i.e., polling).  A Get is
	// the equivalent of a Subscribe with once set, with the exception that all
	// the key value pairs will be returned in a single response.
	Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error)
	// Set sets the paths contained in the SetRequest to the values If a path does
	// not exist, or is read-only the SetResponse will return an error.  All paths
	// in the SetRequest must be valid or the entire request must be rejected.  If
	// a path specifies a node, rather than the leaf, then the value must be the
	// values of the node's children encoded in JSON.  Binary data in the tree
	// must be base64 encoded.
	Set(ctx context.Context, opts ...grpc.CallOption) (OpenConfig_SetClient, error)
}

type openConfigClient struct {
	cc *grpc.ClientConn
}

func NewOpenConfigClient(cc *grpc.ClientConn) OpenConfigClient {
	return &openConfigClient{cc}
}

func (c *openConfigClient) Subscribe(ctx context.Context, opts ...grpc.CallOption) (OpenConfig_SubscribeClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_OpenConfig_serviceDesc.Streams[0], c.cc, "/openconfig.OpenConfig/Subscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &openConfigSubscribeClient{stream}
	return x, nil
}

type OpenConfig_SubscribeClient interface {
	Send(*SubscribeRequest) error
	Recv() (*SubscribeResponse, error)
	grpc.ClientStream
}

type openConfigSubscribeClient struct {
	grpc.ClientStream
}

func (x *openConfigSubscribeClient) Send(m *SubscribeRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *openConfigSubscribeClient) Recv() (*SubscribeResponse, error) {
	m := new(SubscribeResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *openConfigClient) Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error) {
	out := new(GetResponse)
	err := grpc.Invoke(ctx, "/openconfig.OpenConfig/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *openConfigClient) Set(ctx context.Context, opts ...grpc.CallOption) (OpenConfig_SetClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_OpenConfig_serviceDesc.Streams[1], c.cc, "/openconfig.OpenConfig/Set", opts...)
	if err != nil {
		return nil, err
	}
	x := &openConfigSetClient{stream}
	return x, nil
}

type OpenConfig_SetClient interface {
	Send(*SetRequest) error
	Recv() (*SetResponse, error)
	grpc.ClientStream
}

type openConfigSetClient struct {
	grpc.ClientStream
}

func (x *openConfigSetClient) Send(m *SetRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *openConfigSetClient) Recv() (*SetResponse, error) {
	m := new(SetResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for OpenConfig service

type OpenConfigServer interface {
	// Subscribe subscribes for streaming updates.  Streaming updates are provided
	// as a series of Notifications, each of which update a portion of the tree.
	// The target must send the current values of all subscribed paths at the
	// start of the stream, followed by a sync_response of 0.
	//
	// A Subscription operates in one of three modes.
	//
	// Streaming:  This is the default mode.  The target sends continual updates
	// of each value as specified by each subscription's coalesce_interval.  The
	// client may request the target to resend the current value of a set of paths
	// by sending a SyncRequest.
	//
	// Once: This mode is specified by setting once to true in the
	// SubscriptionRequest.  The target must close the stream after sending
	// the sync_response of 0.  The target should only send each value once.
	//
	// Poll: This mode is the equivalent of periodic Once requests but sent over a
	// single stream.  Polling is specified by setting poll_interval in the
	// SubscriptionRequest to the expected number of nanoseconds between polls.
	// The target stops sending updates after sending the sync_response of 0.
	// After the polling interval, the client sends a new SubscriptionRequest with
	// only the poll_interval set.  The target must respond by sending the current
	// values of all subscribed paths, once again followed with a sync_response of
	// 0.  This process then repeats until the client closes the request stream.
	Subscribe(OpenConfig_SubscribeServer) error
	// Get requests a single snapshot of the requested data.  A Get request may
	// contain a hint that the request will be repeated (i.e., polling).  A Get is
	// the equivalent of a Subscribe with once set, with the exception that all
	// the key value pairs will be returned in a single response.
	Get(context.Context, *GetRequest) (*GetResponse, error)
	// Set sets the paths contained in the SetRequest to the values If a path does
	// not exist, or is read-only the SetResponse will return an error.  All paths
	// in the SetRequest must be valid or the entire request must be rejected.  If
	// a path specifies a node, rather than the leaf, then the value must be the
	// values of the node's children encoded in JSON.  Binary data in the tree
	// must be base64 encoded.
	Set(OpenConfig_SetServer) error
}

func RegisterOpenConfigServer(s *grpc.Server, srv OpenConfigServer) {
	s.RegisterService(&_OpenConfig_serviceDesc, srv)
}

func _OpenConfig_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(OpenConfigServer).Subscribe(&openConfigSubscribeServer{stream})
}

type OpenConfig_SubscribeServer interface {
	Send(*SubscribeResponse) error
	Recv() (*SubscribeRequest, error)
	grpc.ServerStream
}

type openConfigSubscribeServer struct {
	grpc.ServerStream
}

func (x *openConfigSubscribeServer) Send(m *SubscribeResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *openConfigSubscribeServer) Recv() (*SubscribeRequest, error) {
	m := new(SubscribeRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _OpenConfig_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OpenConfigServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/openconfig.OpenConfig/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OpenConfigServer).Get(ctx, req.(*GetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OpenConfig_Set_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(OpenConfigServer).Set(&openConfigSetServer{stream})
}

type OpenConfig_SetServer interface {
	Send(*SetResponse) error
	Recv() (*SetRequest, error)
	grpc.ServerStream
}

type openConfigSetServer struct {
	grpc.ServerStream
}

func (x *openConfigSetServer) Send(m *SetResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *openConfigSetServer) Recv() (*SetRequest, error) {
	m := new(SetRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _OpenConfig_serviceDesc = grpc.ServiceDesc{
	ServiceName: "openconfig.OpenConfig",
	HandlerType: (*OpenConfigServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _OpenConfig_Get_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Subscribe",
			Handler:       _OpenConfig_Subscribe_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Set",
			Handler:       _OpenConfig_Set_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
}

var fileDescriptor0 = []byte{
	// 998 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x9c, 0x56, 0xcb, 0x6e, 0x23, 0x45,
	0x17, 0x9e, 0xb6, 0xdb, 0x97, 0x3e, 0x76, 0xfc, 0xdb, 0xa5, 0xf9, 0x19, 0x63, 0x06, 0x11, 0xb5,
	0x06, 0x12, 0x05, 0xe1, 0x01, 0x73, 0x59, 0x20, 0x84, 0x94, 0xc0, 0x88, 0x01, 0x46, 0xc9, 0xa8,
	0x9c, 0x30, 0x62, 0x65, 0x95, 0x9d, 0x4a, 0xd2, 0x92, 0xdd, 0xdd, 0x74, 0xb5, 0xd1, 0x78, 0xc1,
	0x8a, 0x1d, 0xe2, 0x4d, 0x58, 0xf1, 0x0a, 0x88, 0x35, 0xcf, 0xc4, 0xa9, 0x5b, 0x77, 0x39, 0x89,
	0x83, 0x67, 0x76, 0x5d, 0xe7, 0x7e, 0xbe, 0xf3, 0xf5, 0xa9, 0x82, 0x6e, 0x92, 0xf2, 0x78, 0x96,
	0xc4, 0x17, 0xd1, 0xe5, 0x30, 0xcd, 0x92, 0x3c, 0x21, 0x50, 0x4a, 0x06, 0x6f, 0x5e, 0x26, 0xc9,
	0xe5, 0x9c, 0x3f, 0x56, 0x9a, 0xe9, 0xf2, 0xe2, 0x31, 0x8b, 0x57, 0xda, 0x2c, 0xdc, 0x05, 0xff,
	0x39, 0xcb, 0xaf, 0x48, 0x1f, 0x1a, 0x7c, 0xce, 0x17, 0x3c, 0xce, 0xfb, 0xde, 0x6e, 0x75, 0x3f,
	0xa0, 0xf6, 0x18, 0xbe, 0x80, 0xda, 0x0f, 0x6c, 0xbe, 0xe4, 0xe4, 0x3e, 0xd4, 0x7e, 0x96, 0x1f,
	0x68, 0xe0, 0xed, 0xb7, 0xa9, 0x3e, 0x90, 0x47, 0xe0, 0xe7, 0xab, 0x94, 0xf7, 0x2b, 0x28, 0xec,
	0x8c, 0xba, 0x43, 0xa7, 0x90, 0x53, 0x94, 0x53, 0xa5, 0x25, 0x04, 0xfc, 0x98, 0x2d, 0x78, 0xbf,
	0x8a, 0x56, 0x01, 0x55, 0xdf, 0x18, 0xb8, 0x7e, 0x96, 0x9e, 0xb3, 0x5c, 0xc5, 0x48, 0xb1, 0x08,
	0x15, 0xb8, 0xb5, 0x1e, 0x43, 0x16, 0x47, 0x95, 0x96, 0xec, 0xd9, 0xfc, 0x15, 0x65, 0xd6, 0x73,
	0xcd, 0x54, 0x85, 0xa6, 0xa4, 0xf0, 0x2f, 0x0f, 0xda, 0xc7, 0x49, 0x1e, 0x5d, 0x44, 0x33, 0x96,
	0x47, 0x49, 0x4c, 0x1e, 0x42, 0x90, 0x47, 0x0b, 0x2e, 0x72, 0xb6, 0x48, 0x55, 0x92, 0x2a, 0x2d,
	0x05, 0x64, 0x1f, 0xea, 0x69, 0xc6, 0x2f, 0xa2, 0x97, 0x26, 0xf0, 0xcd, 0xfc, 0x46, 0x2f, 0x11,
	0x60, 0xf3, 0x88, 0x09, 0xd3, 0x86, 0x3e, 0x90, 0x03, 0xa8, 0x2f, 0x55, 0x1f, 0x7d, 0x1f, 0x91,
	0x6b, 0x8d, 0x88, 0xeb, 0xaf, 0x3b, 0xa4, 0xc6, 0x42, 0xe6, 0x3a, 0x47, 0x60, 0xd1, 0xb6, 0xa6,
	0x6c, 0x6f, 0xc9, 0xa5, 0xf5, 0xe1, 0xdf, 0x1e, 0xc0, 0xd9, 0xd7, 0xcf, 0x5f, 0x64, 0x2c, 0x4d,
	0x79, 0x46, 0x76, 0xa1, 0x12, 0x9d, 0x6f, 0x04, 0x08, 0x75, 0xe4, 0x03, 0x20, 0x79, 0xc6, 0x62,
	0xb1, 0x88, 0xf2, 0x49, 0xd9, 0xad, 0x6c, 0xc9, 0xa7, 0x3d, 0xab, 0x39, 0x2d, 0xba, 0xde, 0x83,
	0xff, 0x09, 0xfe, 0xd3, 0x12, 0xe3, 0xf0, 0x49, 0xbc, 0x5c, 0x4c, 0x79, 0xa6, 0xba, 0xf2, 0x69,
	0xc7, 0x8a, 0x8f, 0x95, 0x94, 0x7c, 0x01, 0xed, 0xd8, 0x01, 0xd3, 0x34, 0xd9, 0x77, 0x6b, 0x70,
	0xc1, 0xa6, 0x6b, 0xd6, 0xe1, 0x04, 0x6a, 0x4f, 0xb2, 0x2c, 0xc9, 0x24, 0x03, 0x66, 0xc9, 0xb9,
	0x26, 0xcf, 0x0e, 0x55, 0xdf, 0x92, 0x74, 0x58, 0x8e, 0x60, 0x97, 0x7a, 0xa6, 0x48, 0x3a, 0x73,
	0x44, 0x9c, 0x7c, 0xc4, 0x8b, 0xa9, 0x92, 0x5a, 0xa3, 0xfb, 0x43, 0x4d, 0xe0, 0xa1, 0x25, 0xf0,
	0xf0, 0x30, 0x5e, 0x51, 0x65, 0x11, 0xfe, 0x56, 0x81, 0xee, 0x78, 0x39, 0x15, 0xb3, 0x2c, 0x9a,
	0x72, 0x2a, 0x4b, 0x17, 0x39, 0xd6, 0x1c, 0x08, 0x2b, 0x33, 0xa0, 0x3d, 0x74, 0x0b, 0x36, 0x0e,
	0xa9, 0x2c, 0xf1, 0x59, 0x24, 0xf2, 0xa7, 0xf7, 0x68, 0xe9, 0x40, 0x3e, 0x85, 0xe0, 0x8a, 0xb3,
	0x2c, 0x9f, 0x72, 0x96, 0x1b, 0x4e, 0xfc, 0xdf, 0xf5, 0x7e, 0x6a, 0x95, 0xd2, 0xad, 0xb0, 0xc4,
	0x01, 0xf8, 0x62, 0x15, 0xcf, 0x4c, 0xcd, 0x0f, 0xd6, 0xf2, 0xa1, 0xdc, 0xd4, 0x86, 0x3e, 0xca,
	0x8c, 0x7c, 0x04, 0x0d, 0xc5, 0x1f, 0x2e, 0x10, 0xd2, 0x1b, 0x39, 0x0e, 0xa5, 0xca, 0x94, 0x66,
	0xed, 0x24, 0xff, 0x10, 0x81, 0x97, 0x2b, 0x45, 0x1e, 0xe4, 0x9f, 0x3a, 0x1c, 0x05, 0xd0, 0xc8,
	0x74, 0xec, 0xf0, 0x4f, 0x0f, 0x7a, 0x0e, 0x18, 0x22, 0x4d, 0x62, 0xc1, 0xc9, 0xa8, 0x20, 0xa8,
	0x86, 0x62, 0xe3, 0xec, 0x30, 0x97, 0x25, 0xea, 0x6b, 0x62, 0xf0, 0x2e, 0xec, 0xc8, 0xe6, 0x26,
	0x99, 0xc9, 0xad, 0x39, 0x85, 0x36, 0x6d, 0xa1, 0x20, 0xd0, 0xd2, 0x23, 0x80, 0xa6, 0xb5, 0x08,
	0xff, 0x28, 0x07, 0x58, 0xcc, 0x03, 0x3b, 0xf5, 0x13, 0xa4, 0x60, 0x1f, 0xd0, 0xbd, 0x29, 0x21,
	0x93, 0x27, 0x19, 0x3d, 0x4d, 0xe6, 0xf3, 0x49, 0x14, 0xe7, 0x3c, 0xc3, 0x7f, 0xbd, 0xdf, 0xb2,
	0xd1, 0xa5, 0xf8, 0x5b, 0x23, 0x95, 0x8c, 0x15, 0x4e, 0x40, 0xb5, 0xd0, 0xae, 0x75, 0xed, 0x26,
	0xa4, 0x6b, 0xd6, 0xaf, 0xb0, 0x0e, 0xbe, 0x84, 0x46, 0xa2, 0x7c, 0x84, 0x99, 0xf9, 0xa3, 0xbb,
	0x38, 0x36, 0x3c, 0xd1, 0xb6, 0xd4, 0x3a, 0x0d, 0x0e, 0xa0, 0x61, 0x64, 0xe4, 0x1d, 0x68, 0x2d,
	0x05, 0x9f, 0x58, 0x42, 0xc8, 0x39, 0x35, 0x29, 0xa0, 0xe8, 0x50, 0x4b, 0x8e, 0xea, 0xe0, 0x2f,
	0xf0, 0x97, 0x09, 0x19, 0xb4, 0xdd, 0xc0, 0x5b, 0xae, 0xce, 0xf7, 0xa1, 0x37, 0x4b, 0xd8, 0x9c,
	0x0b, 0xfc, 0xd9, 0x0b, 0xf0, 0xf4, 0x6a, 0xe8, 0x5a, 0x85, 0x85, 0x2f, 0xfc, 0x04, 0x82, 0x82,
	0x7d, 0x72, 0xe9, 0xea, 0x95, 0xa7, 0x41, 0xec, 0xdd, 0xe0, 0xa8, 0xd9, 0x82, 0xe1, 0x19, 0xd4,
	0xd4, 0x79, 0xcb, 0x8a, 0xde, 0xb3, 0x71, 0x37, 0x81, 0x6c, 0xc2, 0xee, 0x41, 0x50, 0x50, 0x8d,
	0x0c, 0xa0, 0x59, 0x54, 0xef, 0xa9, 0xea, 0x8b, 0x73, 0xb8, 0x80, 0x96, 0xf3, 0x97, 0x91, 0x4e,
	0xb1, 0x2f, 0x7d, 0xb5, 0x1d, 0xb7, 0x9f, 0xaa, 0xad, 0xbf, 0xba, 0x61, 0x41, 0x2b, 0x6d, 0xf8,
	0x2b, 0xae, 0xe7, 0x6f, 0x78, 0x6e, 0xd3, 0x95, 0xe1, 0xbd, 0x2d, 0xc3, 0x57, 0xee, 0x0a, 0x8f,
	0x4c, 0xef, 0xcc, 0xd8, 0xec, 0xca, 0x99, 0x56, 0x55, 0x5d, 0x5b, 0x3b, 0x4a, 0x5a, 0x8c, 0xea,
	0x7b, 0x68, 0xa9, 0x22, 0xcc, 0x8f, 0x7e, 0x7d, 0x55, 0x7b, 0xaf, 0xb4, 0xaa, 0x7f, 0xc7, 0x96,
	0xc6, 0xaf, 0xd3, 0x52, 0x79, 0xa9, 0x55, 0xee, 0xbe, 0xd4, 0x9c, 0xab, 0xb2, 0xfa, 0x5f, 0x57,
	0x65, 0x98, 0xe0, 0x40, 0x9d, 0xde, 0xb6, 0x2f, 0xe7, 0xb3, 0x72, 0xb9, 0x98, 0x82, 0x06, 0xb7,
	0xa4, 0x31, 0x16, 0xb4, 0x5c, 0x44, 0xbf, 0x40, 0x67, 0x5d, 0xb7, 0xfd, 0xbb, 0x84, 0xcb, 0x2b,
	0xee, 0xb6, 0x77, 0x89, 0xba, 0xfb, 0xa8, 0xd6, 0xaf, 0x3f, 0x43, 0xaa, 0xd7, 0x9e, 0x21, 0x07,
	0x6f, 0x81, 0x2f, 0x1f, 0x4c, 0xa4, 0x09, 0xfe, 0x77, 0xe3, 0x93, 0xe3, 0xee, 0x3d, 0x12, 0x40,
	0xed, 0xe8, 0xc7, 0xd3, 0x27, 0xe3, 0xae, 0x37, 0xfa, 0x07, 0x67, 0x73, 0x82, 0x61, 0xbf, 0x52,
	0x61, 0xc9, 0x33, 0x08, 0x8a, 0x35, 0x4f, 0x6e, 0xbb, 0xd9, 0x8a, 0xab, 0x70, 0xf0, 0xf6, 0x06,
	0xad, 0x6e, 0x71, 0xdf, 0xfb, 0xd0, 0x43, 0xc0, 0xaa, 0xc8, 0x22, 0xf2, 0x86, 0x6b, 0x59, 0x72,
	0x7b, 0xf0, 0xe0, 0x86, 0xdc, 0xc0, 0xf3, 0x39, 0x54, 0xc7, 0xd7, 0xfd, 0xc6, 0x1b, 0xfc, 0x9c,
	0x51, 0xca, 0x9c, 0xd3, 0xba, 0xba, 0xca, 0x3f, 0xfe, 0x37, 0x00, 0x00, 0xff, 0xff, 0x3d, 0xb2,
	0x32, 0x28, 0xb9, 0x0a, 0x00, 0x00,
}
